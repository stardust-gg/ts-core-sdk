/* tslint:disable */
/* eslint-disable */
/**
 * Stardust API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2023-05-08T04:33:59Z
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'message'?: string;
}
/**
 * This is the data output json model
 * @export
 * @interface SDGameGetResponse
 */
export interface SDGameGetResponse {
    /**
     * Game ID Number (unsigned 32 bit integer)
     * @type {number}
     * @memberof SDGameGetResponse
     */
    'id': number;
    /**
     * Game Owner ID
     * @type {string}
     * @memberof SDGameGetResponse
     */
    'ownerId': string;
    /**
     * Game name
     * @type {string}
     * @memberof SDGameGetResponse
     */
    'name': string;
    /**
     * Game description
     * @type {string}
     * @memberof SDGameGetResponse
     */
    'desc': string;
    /**
     * Game image
     * @type {string}
     * @memberof SDGameGetResponse
     */
    'image': string;
    /**
     * Game bucket name
     * @type {string}
     * @memberof SDGameGetResponse
     */
    'bucketName': string;
    /**
     * Game news
     * @type {string}
     * @memberof SDGameGetResponse
     */
    'news'?: string;
    /**
     * 
     * @type {Array<SDGameGetResponseFeesInner>}
     * @memberof SDGameGetResponse
     */
    'fees'?: Array<SDGameGetResponseFeesInner>;
    /**
     * Game properties
     * @type {object}
     * @memberof SDGameGetResponse
     */
    'props'?: object;
    /**
     * If on test mode features are enabled. Currently in development.
     * @type {boolean}
     * @memberof SDGameGetResponse
     */
    'testMode'?: boolean;
}
/**
 * 
 * @export
 * @interface SDGameGetResponseFeesInner
 */
export interface SDGameGetResponseFeesInner {
    /**
     * The integer value of feePercentage. 
     * @type {number}
     * @memberof SDGameGetResponseFeesInner
     */
    'feePercentage'?: number;
    /**
     * The type of fee
     * @type {string}
     * @memberof SDGameGetResponseFeesInner
     */
    'feeType'?: string;
}
/**
 * 
 * @export
 * @interface SDGameMutateRequest
 */
export interface SDGameMutateRequest {
    /**
     * The games description
     * @type {string}
     * @memberof SDGameMutateRequest
     */
    'description'?: string;
    /**
     * The games news
     * @type {string}
     * @memberof SDGameMutateRequest
     */
    'news'?: string;
    /**
     * Game properties
     * @type {object}
     * @memberof SDGameMutateRequest
     */
    'props'?: object;
    /**
     * Test mode will enable any test mode features. Currently in development.
     * @type {boolean}
     * @memberof SDGameMutateRequest
     */
    'testMode'?: boolean;
}
/**
 * Data model for the /health response
 * @export
 * @interface SDHealthResponse
 */
export interface SDHealthResponse {
    /**
     * Connect to AWS subsystems worked properly, i.e. OK
     * @type {string}
     * @memberof SDHealthResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface SDOrderBuyRequest
 */
export interface SDOrderBuyRequest {
    /**
     * Order ID Number (unsigned 32 bit integer)
     * @type {number}
     * @memberof SDOrderBuyRequest
     */
    'orderId': number;
    /**
     * The player who accepted the order
     * @type {string}
     * @memberof SDOrderBuyRequest
     */
    'acceptedBy': string;
}
/**
 * 
 * @export
 * @interface SDOrderCancelRequest
 */
export interface SDOrderCancelRequest {
    /**
     * The Player\'s id, can be found with Player/getId(s). Also returned from player/create (ex. CzySggxVQz51jciGRFDY7d5BER2fav6TNEnPGjusPJPd)
     * @type {string}
     * @memberof SDOrderCancelRequest
     */
    'fromPlayerId'?: string;
    /**
     * Game ID Number (unsigned 32 bit integer)
     * @type {number}
     * @memberof SDOrderCancelRequest
     */
    'gameId': number;
    /**
     * Order ID Number (unsigned 32 bit integer)
     * @type {number}
     * @memberof SDOrderCancelRequest
     */
    'orderId': number;
}
/**
 * 
 * @export
 * @interface SDOrderCancelResponse
 */
export interface SDOrderCancelResponse {
    /**
     * Order ID Number (unsigned 32 bit integer)
     * @type {number}
     * @memberof SDOrderCancelResponse
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface SDOrderCreateRequest
 */
export interface SDOrderCreateRequest {
    /**
     * PlayerId creating the order
     * @type {string}
     * @memberof SDOrderCreateRequest
     */
    'offeredBy': string;
    /**
     * 
     * @type {Array<SDOrderCreateTokens>}
     * @memberof SDOrderCreateRequest
     */
    'tokensOffered': Array<SDOrderCreateTokens>;
    /**
     * 
     * @type {Array<SDOrderCreateTokens>}
     * @memberof SDOrderCreateRequest
     */
    'tokensRequested': Array<SDOrderCreateTokens>;
}
/**
 * 
 * @export
 * @interface SDOrderCreateResponse
 */
export interface SDOrderCreateResponse {
    /**
     * The ID of the order created
     * @type {number}
     * @memberof SDOrderCreateResponse
     */
    'id': number;
}
/**
 * 
 * @export
 * @interface SDOrderCreateTokens
 */
export interface SDOrderCreateTokens {
    /**
     * Token ID Number (unsigned 32 bit integer)
     * @type {number}
     * @memberof SDOrderCreateTokens
     */
    'tokenId': number;
    /**
     * u64 Number as String, min: 0, max: 9223372036854775807
     * @type {string}
     * @memberof SDOrderCreateTokens
     */
    'amount': string;
}
/**
 * 
 * @export
 * @interface SDOrderGetAllResponse
 */
export interface SDOrderGetAllResponse {
    /**
     * The playerId who initiated the order
     * @type {string}
     * @memberof SDOrderGetAllResponse
     */
    'offeredBy': string;
    /**
     * The playerId who is being offered a order
     * @type {string}
     * @memberof SDOrderGetAllResponse
     */
    'acceptedBy': string;
    /**
     * 
     * @type {Array<SDOrderGetAllResponseTokensRequestedInner>}
     * @memberof SDOrderGetAllResponse
     */
    'tokensRequested': Array<SDOrderGetAllResponseTokensRequestedInner>;
    /**
     * 
     * @type {Array<SDOrderGetAllResponseTokensRequestedInner>}
     * @memberof SDOrderGetAllResponse
     */
    'tokensOffered': Array<SDOrderGetAllResponseTokensRequestedInner>;
    /**
     * The status of the order
     * @type {string}
     * @memberof SDOrderGetAllResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface SDOrderGetAllResponseTokensRequestedInner
 */
export interface SDOrderGetAllResponseTokensRequestedInner {
    /**
     * Token ID Number (unsigned 32 bit integer)
     * @type {number}
     * @memberof SDOrderGetAllResponseTokensRequestedInner
     */
    'tokenId': number;
    /**
     * Token ID Number (unsigned 32 bit integer)
     * @type {number}
     * @memberof SDOrderGetAllResponseTokensRequestedInner
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface SDOrderGetResponse
 */
export interface SDOrderGetResponse {
    /**
     * The playerId who initiated the order
     * @type {string}
     * @memberof SDOrderGetResponse
     */
    'offeredBy': string;
    /**
     * The playerId who is being offered a order
     * @type {string}
     * @memberof SDOrderGetResponse
     */
    'acceptedBy': string;
    /**
     * 
     * @type {Array<SDOrderGetAllResponseTokensRequestedInner>}
     * @memberof SDOrderGetResponse
     */
    'tokensRequested': Array<SDOrderGetAllResponseTokensRequestedInner>;
    /**
     * 
     * @type {Array<SDOrderGetAllResponseTokensRequestedInner>}
     * @memberof SDOrderGetResponse
     */
    'tokensOffered': Array<SDOrderGetAllResponseTokensRequestedInner>;
    /**
     * The status of the order [\'offer\', \'accepted\', \'cancelled\']
     * @type {string}
     * @memberof SDOrderGetResponse
     */
    'status': string;
}
/**
 * 
 * @export
 * @interface SDPlayerCountResponse
 */
export interface SDPlayerCountResponse {
    /**
     * Game ID Number (unsigned 32 bit integer)
     * @type {number}
     * @memberof SDPlayerCountResponse
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface SDPlayerCreateJWTObject
 */
export interface SDPlayerCreateJWTObject {
    /**
     * Your provider JWT name
     * @type {string}
     * @memberof SDPlayerCreateJWTObject
     */
    'type': string;
    /**
     * idToken of the user session
     * @type {string}
     * @memberof SDPlayerCreateJWTObject
     */
    'idToken'?: string;
    /**
     * Access token of the user session
     * @type {string}
     * @memberof SDPlayerCreateJWTObject
     */
    'accessToken'?: string;
}
/**
 * 
 * @export
 * @interface SDPlayerCreateRequest
 */
export interface SDPlayerCreateRequest {
    /**
     * Identifier for the player
     * @type {string}
     * @memberof SDPlayerCreateRequest
     */
    'uniqueId': string;
    /**
     * URL of the player\'s image
     * @type {string}
     * @memberof SDPlayerCreateRequest
     */
    'image'?: string;
    /**
     * Metadata about the player
     * @type {object}
     * @memberof SDPlayerCreateRequest
     */
    'userData': object;
}
/**
 * The id of the player created
 * @export
 * @interface SDPlayerCreateResponse
 */
export interface SDPlayerCreateResponse {
    /**
     * Player\'s ID in UUID format
     * @type {string}
     * @memberof SDPlayerCreateResponse
     */
    'playerId': string;
}
/**
 * This is the data output json model
 * @export
 * @interface SDPlayerGetAllResponse
 */
export interface SDPlayerGetAllResponse {
    [key: string]: string | any;

    /**
     * Player ID in the form of a UUID
     * @type {string}
     * @memberof SDPlayerGetAllResponse
     */
    'playerId': string;
    /**
     * Game player\'s unique ID from the game itself
     * @type {string}
     * @memberof SDPlayerGetAllResponse
     */
    'uniqueId': string;
    /**
     * Game player\'s ID in the database
     * @type {number}
     * @memberof SDPlayerGetAllResponse
     */
    'id'?: number;
    /**
     * Date and time the player was \'last seen\' actively participating in the game
     * @type {string}
     * @memberof SDPlayerGetAllResponse
     */
    'lastSeen'?: string;
    /**
     * URL of image cached by Stardust
     * @type {string}
     * @memberof SDPlayerGetAllResponse
     */
    'image'?: string;
}
/**
 * This is the data output json model
 * @export
 * @interface SDPlayerGetIdResponse
 */
export interface SDPlayerGetIdResponse {
    /**
     * Player\'s Id
     * @type {string}
     * @memberof SDPlayerGetIdResponse
     */
    'playerId': string;
}
/**
 * This is the data output json model, i.e. {\"uniqueId\": \"playerId\"} 
 * @export
 * @interface SDPlayerGetIdsResponse
 */
export interface SDPlayerGetIdsResponse {
    /**
     * Player ID in the form of a UUID
     * @type {string}
     * @memberof SDPlayerGetIdsResponse
     */
    'playerId': string;
    /**
     * Player ID in the form of a the game player\'s internal playerId, i.e. email address, uuid
     * @type {string}
     * @memberof SDPlayerGetIdsResponse
     */
    'uniqueId': string;
}
/**
 * This is the data output json model
 * @export
 * @interface SDPlayerGetInventoryResponse
 */
export interface SDPlayerGetInventoryResponse {
    /**
     * Token ID
     * @type {number}
     * @memberof SDPlayerGetInventoryResponse
     */
    'tokenId': number;
    /**
     * u64 Number as String, min: 0, max: 9223372036854775807
     * @type {string}
     * @memberof SDPlayerGetInventoryResponse
     */
    'amount': string;
}
/**
 * This is the data output json model
 * @export
 * @interface SDPlayerGetResponse
 */
export interface SDPlayerGetResponse {
    [key: string]: string | any;

    /**
     * Player ID in the form of a UUID
     * @type {string}
     * @memberof SDPlayerGetResponse
     */
    'playerId': string;
    /**
     * Player ID in the form of a the game owner\'s internal playerId, i.e. email address
     * @type {string}
     * @memberof SDPlayerGetResponse
     */
    'uniqueId': string;
    /**
     * Date and time the player was \'last seen\' actively participating in the game
     * @type {string}
     * @memberof SDPlayerGetResponse
     */
    'lastSeen'?: string;
    /**
     * URL of image cached by Stardust
     * @type {string}
     * @memberof SDPlayerGetResponse
     */
    'image'?: string;
}
/**
 * 
 * @export
 * @interface SDPlayerMutateRequest
 */
export interface SDPlayerMutateRequest {
    /**
     * Can be found with Player/getId(s).
     * @type {string}
     * @memberof SDPlayerMutateRequest
     */
    'playerId': string;
    /**
     * Specifies which properties you want to change (ex. {prop1: 5, prop2: 6, prop3: 7})
     * @type {object}
     * @memberof SDPlayerMutateRequest
     */
    'props': object;
}
/**
 * This is the data output json model
 * @export
 * @interface SDPlayerWalletGetResponse
 */
export interface SDPlayerWalletGetResponse {
    /**
     * An array of player wallets on the blockchain
     * @type {Array<SDPlayerWalletGetResponseWalletInner>}
     * @memberof SDPlayerWalletGetResponse
     */
    'wallet': Array<SDPlayerWalletGetResponseWalletInner>;
}
/**
 * 
 * @export
 * @interface SDPlayerWalletGetResponseWalletInner
 */
export interface SDPlayerWalletGetResponseWalletInner {
    /**
     * The name of the blockchain
     * @type {string}
     * @memberof SDPlayerWalletGetResponseWalletInner
     */
    'blockchain': string;
    /**
     * The players blockchain Address
     * @type {string}
     * @memberof SDPlayerWalletGetResponseWalletInner
     */
    'address': string;
    /**
     * An array of the players balances on a given blockchain
     * @type {Array<SDPlayerWalletGetResponseWalletInnerMoniesInner>}
     * @memberof SDPlayerWalletGetResponseWalletInner
     */
    'monies'?: Array<SDPlayerWalletGetResponseWalletInnerMoniesInner>;
}
/**
 * The Money object representation of the balance
 * @export
 * @interface SDPlayerWalletGetResponseWalletInnerMoniesInner
 */
export interface SDPlayerWalletGetResponseWalletInnerMoniesInner {
    /**
     * The balance in minor units. ex: 2000000 for 2 coins USDC
     * @type {string}
     * @memberof SDPlayerWalletGetResponseWalletInnerMoniesInner
     */
    'amount'?: string;
    /**
     * The currency code associated with the amount. ex: \'USDC\'
     * @type {string}
     * @memberof SDPlayerWalletGetResponseWalletInnerMoniesInner
     */
    'currency'?: string;
}
/**
 * 
 * @export
 * @interface SDPlayerWithdrawObject
 */
export interface SDPlayerWithdrawObject {
    /**
     * 
     * @type {number}
     * @memberof SDPlayerWithdrawObject
     */
    'tokenId': number;
    /**
     * u64 Number as String, min: 0, max: 9223372036854775807
     * @type {string}
     * @memberof SDPlayerWithdrawObject
     */
    'amount': string;
}
/**
 * 
 * @export
 * @interface SDPlayerWithdrawRequest
 */
export interface SDPlayerWithdrawRequest {
    /**
     * Blockchain Address
     * @type {string}
     * @memberof SDPlayerWithdrawRequest
     */
    'address': string;
    /**
     * The Player\'s id, can be found with Player/getId(s). Also returned from player/create (ex. CzySggxVQz51jciGRFDY7d5BER2fav6TNEnPGjusPJPd)
     * @type {string}
     * @memberof SDPlayerWithdrawRequest
     */
    'playerId': string;
    /**
     * array of Token objects
     * @type {Array<SDPlayerWithdrawObject>}
     * @memberof SDPlayerWithdrawRequest
     */
    'tokenObjects': Array<SDPlayerWithdrawObject>;
}
/**
 * 
 * @export
 * @interface SDTemplateCountResponse
 */
export interface SDTemplateCountResponse {
    /**
     * Game ID Number (unsigned 32 bit integer)
     * @type {number}
     * @memberof SDTemplateCountResponse
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface SDTemplateCreateBulk
 */
export interface SDTemplateCreateBulk {
    /**
     * The name of the template (ex. Bronze Axe)
     * @type {string}
     * @memberof SDTemplateCreateBulk
     */
    'name': string;
    /**
     * u96 Number as String (ex. 200000000), default 39614081257132168796771975168 
     * @type {string}
     * @memberof SDTemplateCreateBulk
     */
    'cap'?: string;
    /**
     * The type of custom contract to use for this template. Default will use a shared contract.
     * @type {string}
     * @memberof SDTemplateCreateBulk
     */
    'contractType'?: SDTemplateCreateBulkContractTypeEnum;
    /**
     * FT is a currency where every instance is the same, NFT is where every token instance differes (ex. FT)
     * @type {string}
     * @memberof SDTemplateCreateBulk
     */
    'type'?: SDTemplateCreateBulkTypeEnum;
    /**
     * image url
     * @type {string}
     * @memberof SDTemplateCreateBulk
     */
    'image': string;
    /**
     * Description of template
     * @type {string}
     * @memberof SDTemplateCreateBulk
     */
    'description'?: string;
    /**
     * Set if the Template is active or not
     * @type {boolean}
     * @memberof SDTemplateCreateBulk
     */
    'activeListing'?: boolean;
    /**
     * Blockchain address to set as owner of the custom contract, if contractType is passed in.
     * @type {string}
     * @memberof SDTemplateCreateBulk
     */
    'ownerAddress'?: string;
    /**
     * 
     * @type {SDTemplateCreateBulkProps}
     * @memberof SDTemplateCreateBulk
     */
    'props'?: SDTemplateCreateBulkProps;
    /**
     * Returned to marketplaces as contract metadata
     * @type {object}
     * @memberof SDTemplateCreateBulk
     */
    'publicContractMetadata'?: object;
    /**
     * Inherited by tokens, and returned to marketplaces as token metadata
     * @type {object}
     * @memberof SDTemplateCreateBulk
     */
    'publicTokenMetadata'?: object;
}

export const SDTemplateCreateBulkContractTypeEnum = {
    Erc721: 'ERC721'
} as const;

export type SDTemplateCreateBulkContractTypeEnum = typeof SDTemplateCreateBulkContractTypeEnum[keyof typeof SDTemplateCreateBulkContractTypeEnum];
export const SDTemplateCreateBulkTypeEnum = {
    Ft: 'FT',
    Nft: 'NFT'
} as const;

export type SDTemplateCreateBulkTypeEnum = typeof SDTemplateCreateBulkTypeEnum[keyof typeof SDTemplateCreateBulkTypeEnum];

/**
 * 
 * @export
 * @interface SDTemplateCreateBulkProps
 */
export interface SDTemplateCreateBulkProps {
    /**
     * Properties for immutable on the Template
     * @type {object}
     * @memberof SDTemplateCreateBulkProps
     */
    'immutable'?: object;
    /**
     * Properties for mutable on the Template
     * @type {object}
     * @memberof SDTemplateCreateBulkProps
     */
    'mutable'?: object;
    /**
     * Properties for mutable on the Item
     * @type {object}
     * @memberof SDTemplateCreateBulkProps
     */
    '$mutable'?: object;
}
/**
 * 
 * @export
 * @interface SDTemplateCreateRequest
 */
export interface SDTemplateCreateRequest {
    /**
     * The name of the template (ex. Bronze Axe)
     * @type {string}
     * @memberof SDTemplateCreateRequest
     */
    'name': string;
    /**
     * u96 Number as String (ex. 200000000) 
     * @type {string}
     * @memberof SDTemplateCreateRequest
     */
    'cap': string;
    /**
     * The type of custom contract to use for this template. Default will use a shared contract.
     * @type {string}
     * @memberof SDTemplateCreateRequest
     */
    'contractType'?: SDTemplateCreateRequestContractTypeEnum;
    /**
     * FT is a currency where every instance is the same, NFT is where every token instance differes (ex. FT)
     * @type {string}
     * @memberof SDTemplateCreateRequest
     */
    'type': SDTemplateCreateRequestTypeEnum;
    /**
     * Blockchain address to set as owner of the custom contract. Required if contractType is set.
     * @type {string}
     * @memberof SDTemplateCreateRequest
     */
    'ownerAddress'?: string;
    /**
     * 
     * @type {SDTemplateCreateRequestProps}
     * @memberof SDTemplateCreateRequest
     */
    'props': SDTemplateCreateRequestProps;
    /**
     * Returned to marketplaces as contract metadata
     * @type {object}
     * @memberof SDTemplateCreateRequest
     */
    'publicContractMetadata'?: object;
    /**
     * For ERC20 contracts, this is the ticker symbol
     * @type {string}
     * @memberof SDTemplateCreateRequest
     */
    'symbol'?: string;
}

export const SDTemplateCreateRequestContractTypeEnum = {
    InternalMint: 'internal-mint',
    Erc721: 'ERC721',
    Erc20: 'ERC20'
} as const;

export type SDTemplateCreateRequestContractTypeEnum = typeof SDTemplateCreateRequestContractTypeEnum[keyof typeof SDTemplateCreateRequestContractTypeEnum];
export const SDTemplateCreateRequestTypeEnum = {
    Ft: 'FT',
    Nft: 'NFT'
} as const;

export type SDTemplateCreateRequestTypeEnum = typeof SDTemplateCreateRequestTypeEnum[keyof typeof SDTemplateCreateRequestTypeEnum];

/**
 * 
 * @export
 * @interface SDTemplateCreateRequestProps
 */
export interface SDTemplateCreateRequestProps {
    /**
     * Properties for immutable on the Template
     * @type {object}
     * @memberof SDTemplateCreateRequestProps
     */
    'immutable'?: object;
    /**
     * Properties for mutable on the Template
     * @type {object}
     * @memberof SDTemplateCreateRequestProps
     */
    'mutable'?: object;
}
/**
 * The id of the template created
 * @export
 * @interface SDTemplateCreateResponse
 */
export interface SDTemplateCreateResponse {
    /**
     * 
     * @type {number}
     * @memberof SDTemplateCreateResponse
     */
    'id'?: number;
}
/**
 * 
 * @export
 * @interface SDTemplateGetAllResponse
 */
export interface SDTemplateGetAllResponse {
    /**
     * Game ID Number (unsigned 32 bit integer)
     * @type {number}
     * @memberof SDTemplateGetAllResponse
     */
    'gameId': number;
    /**
     * 
     * @type {number}
     * @memberof SDTemplateGetAllResponse
     */
    '_id': number;
    /**
     * u96 Number as String, min: 0, max: 39614081257132168796771975167
     * @type {string}
     * @memberof SDTemplateGetAllResponse
     */
    'cap': string;
    /**
     * The type of custom contract bieng used for this template.
     * @type {string}
     * @memberof SDTemplateGetAllResponse
     */
    'contractType'?: SDTemplateGetAllResponseContractTypeEnum;
    /**
     * u96 Number as String, min: 0, max: 39614081257132168796771975167
     * @type {string}
     * @memberof SDTemplateGetAllResponse
     */
    'totalSupply': string;
    /**
     * The name of the template
     * @type {string}
     * @memberof SDTemplateGetAllResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SDTemplateGetAllResponse
     */
    'type': SDTemplateGetAllResponseTypeEnum;
    /**
     * 
     * @type {SDTemplateGetAllResponseProps}
     * @memberof SDTemplateGetAllResponse
     */
    'props': SDTemplateGetAllResponseProps;
    /**
     * Returned to marketplaces as contract metadata
     * @type {object}
     * @memberof SDTemplateGetAllResponse
     */
    'publicContractMetadata'?: object;
    /**
     * Inherited by tokens, and returned to marketplaces as token metadata
     * @type {object}
     * @memberof SDTemplateGetAllResponse
     */
    'publicTokenMetadata'?: object;
}

export const SDTemplateGetAllResponseContractTypeEnum = {
    Erc721: 'ERC721',
    InternalMint: 'internal-mint',
    ExternalNoMint: 'external-no-mint'
} as const;

export type SDTemplateGetAllResponseContractTypeEnum = typeof SDTemplateGetAllResponseContractTypeEnum[keyof typeof SDTemplateGetAllResponseContractTypeEnum];
export const SDTemplateGetAllResponseTypeEnum = {
    Ft: 'FT',
    Nft: 'NFT'
} as const;

export type SDTemplateGetAllResponseTypeEnum = typeof SDTemplateGetAllResponseTypeEnum[keyof typeof SDTemplateGetAllResponseTypeEnum];

/**
 * 
 * @export
 * @interface SDTemplateGetAllResponseProps
 */
export interface SDTemplateGetAllResponseProps {
    /**
     * 
     * @type {object}
     * @memberof SDTemplateGetAllResponseProps
     */
    'immutable': object;
    /**
     * 
     * @type {object}
     * @memberof SDTemplateGetAllResponseProps
     */
    'mutable': object;
    /**
     * 
     * @type {object}
     * @memberof SDTemplateGetAllResponseProps
     */
    '$mutable': object;
}
/**
 * 
 * @export
 * @interface SDTemplateGetResponse
 */
export interface SDTemplateGetResponse {
    /**
     * Game ID Number (unsigned 32 bit integer)
     * @type {number}
     * @memberof SDTemplateGetResponse
     */
    'gameId': number;
    /**
     * 
     * @type {number}
     * @memberof SDTemplateGetResponse
     */
    '_id': number;
    /**
     * u96 Number as String, min: 0, max: 39614081257132168796771975167
     * @type {string}
     * @memberof SDTemplateGetResponse
     */
    'cap': string;
    /**
     * The type of custom contract bieng used for this template.
     * @type {string}
     * @memberof SDTemplateGetResponse
     */
    'contractType'?: SDTemplateGetResponseContractTypeEnum;
    /**
     * u96 Number as String, min: 0, max: 39614081257132168796771975167
     * @type {string}
     * @memberof SDTemplateGetResponse
     */
    'totalSupply': string;
    /**
     * The name of the template
     * @type {string}
     * @memberof SDTemplateGetResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof SDTemplateGetResponse
     */
    'type': SDTemplateGetResponseTypeEnum;
    /**
     * 
     * @type {SDTemplateGetAllResponseProps}
     * @memberof SDTemplateGetResponse
     */
    'props': SDTemplateGetAllResponseProps;
    /**
     * Returned to marketplaces as contract metadata
     * @type {object}
     * @memberof SDTemplateGetResponse
     */
    'publicContractMetadata'?: object;
    /**
     * Inherited by tokens, and returned to marketplaces as token metadata
     * @type {object}
     * @memberof SDTemplateGetResponse
     */
    'publicTokenMetadata'?: object;
    /**
     * 
     * @type {Array<SDGameGetResponseFeesInner>}
     * @memberof SDTemplateGetResponse
     */
    'fees'?: Array<SDGameGetResponseFeesInner>;
}

export const SDTemplateGetResponseContractTypeEnum = {
    Erc721: 'ERC721',
    InternalMint: 'internal-mint',
    ExternalNoMint: 'external-no-mint'
} as const;

export type SDTemplateGetResponseContractTypeEnum = typeof SDTemplateGetResponseContractTypeEnum[keyof typeof SDTemplateGetResponseContractTypeEnum];
export const SDTemplateGetResponseTypeEnum = {
    Ft: 'FT',
    Nft: 'NFT'
} as const;

export type SDTemplateGetResponseTypeEnum = typeof SDTemplateGetResponseTypeEnum[keyof typeof SDTemplateGetResponseTypeEnum];

/**
 * Token data
 * @export
 * @interface SDTemplateGetTokensResponse
 */
export interface SDTemplateGetTokensResponse {
    /**
     * 
     * @type {SDTemplateGetTokensResponseToken}
     * @memberof SDTemplateGetTokensResponse
     */
    'token': SDTemplateGetTokensResponseToken;
    /**
     * 
     * @type {SDTemplateGetTokensResponsePlayer}
     * @memberof SDTemplateGetTokensResponse
     */
    'player': SDTemplateGetTokensResponsePlayer;
}
/**
 * 
 * @export
 * @interface SDTemplateGetTokensResponsePlayer
 */
export interface SDTemplateGetTokensResponsePlayer {
    /**
     * Player ID in the form of a UUID
     * @type {string}
     * @memberof SDTemplateGetTokensResponsePlayer
     */
    'id': string;
    /**
     * Player ID in the form of a the game owner\'s internal playerId, i.e. email address
     * @type {string}
     * @memberof SDTemplateGetTokensResponsePlayer
     */
    'uniqueId': string;
    /**
     * URL of image cached by Stardust
     * @type {string}
     * @memberof SDTemplateGetTokensResponsePlayer
     */
    'image'?: string;
    /**
     * Timestamp of when a player was deleted
     * @type {string}
     * @memberof SDTemplateGetTokensResponsePlayer
     */
    'deletedAt'?: string;
}
/**
 * 
 * @export
 * @interface SDTemplateGetTokensResponseToken
 */
export interface SDTemplateGetTokensResponseToken {
    /**
     * Token ID Number (unsigned 32 bit integer)
     * @type {number}
     * @memberof SDTemplateGetTokensResponseToken
     */
    'id': number;
    /**
     * u64 Number as String, min: 0, max: 9223372036854775807 (ex. \"6\")
     * @type {string}
     * @memberof SDTemplateGetTokensResponseToken
     */
    'amount': string;
    /**
     * Template ID Number (unsigned 32 bit integer)
     * @type {number}
     * @memberof SDTemplateGetTokensResponseToken
     */
    'templateId'?: number;
    /**
     * Template Name
     * @type {string}
     * @memberof SDTemplateGetTokensResponseToken
     */
    'name'?: string;
    /**
     * 
     * @type {SDTemplateGetTokensResponseTokenProps}
     * @memberof SDTemplateGetTokensResponseToken
     */
    'props'?: SDTemplateGetTokensResponseTokenProps;
    /**
     * Returned to marketplaces as token metadata
     * @type {object}
     * @memberof SDTemplateGetTokensResponseToken
     */
    'publicMetadata'?: object;
}
/**
 * 
 * @export
 * @interface SDTemplateGetTokensResponseTokenProps
 */
export interface SDTemplateGetTokensResponseTokenProps {
    /**
     * 
     * @type {object}
     * @memberof SDTemplateGetTokensResponseTokenProps
     */
    'immutable': object;
    /**
     * 
     * @type {object}
     * @memberof SDTemplateGetTokensResponseTokenProps
     */
    'mutable': object;
    /**
     * 
     * @type {object}
     * @memberof SDTemplateGetTokensResponseTokenProps
     */
    'inherited': object;
}
/**
 * 
 * @export
 * @interface SDTemplateMutateRequest
 */
export interface SDTemplateMutateRequest {
    /**
     * This is the templateId returned from template/create (ex. 5)
     * @type {number}
     * @memberof SDTemplateMutateRequest
     */
    'templateId': number;
    /**
     * Specifies which properties you want to change (ex. {prop1: 5, prop2: 6, prop3: 7})
     * @type {object}
     * @memberof SDTemplateMutateRequest
     */
    'props'?: object;
    /**
     * Returned to marketplaces as contract metadata
     * @type {object}
     * @memberof SDTemplateMutateRequest
     */
    'publicContractMetadata'?: object;
    /**
     * Inherited by tokens, and returned to marketplaces as token metadata
     * @type {object}
     * @memberof SDTemplateMutateRequest
     */
    'publicTokenMetadata'?: object;
}
/**
 * 
 * @export
 * @interface SDTokenBurnRequest
 */
export interface SDTokenBurnRequest {
    /**
     * The Player\'s id, can be found with Player/getId(s). (ex. CzySggxVQz51jciGRFDY7d5BER2fav6TNEnPGjusPJPd)
     * @type {string}
     * @memberof SDTokenBurnRequest
     */
    'playerId': string;
    /**
     * An an array of objects to burn (ex. [{tokenId: 5, amount: \"6\"}])
     * @type {Array<SDTokenBurnRequestTokenObjectsInner>}
     * @memberof SDTokenBurnRequest
     */
    'tokenObjects': Array<SDTokenBurnRequestTokenObjectsInner>;
}
/**
 * 
 * @export
 * @interface SDTokenBurnRequestTokenObjectsInner
 */
export interface SDTokenBurnRequestTokenObjectsInner {
    /**
     * 
     * @type {number}
     * @memberof SDTokenBurnRequestTokenObjectsInner
     */
    'tokenId': number;
    /**
     * u64 Number as String, min: 0, max: 9223372036854775807
     * @type {string}
     * @memberof SDTokenBurnRequestTokenObjectsInner
     */
    'amount': string;
}
/**
 * token data
 * @export
 * @interface SDTokenGetResponse
 */
export interface SDTokenGetResponse {
    /**
     * Game ID Number (unsigned 32 bit integer)
     * @type {number}
     * @memberof SDTokenGetResponse
     */
    'gameId': number;
    /**
     * Template ID Number (unsigned 32 bit integer)
     * @type {number}
     * @memberof SDTokenGetResponse
     */
    'templateId': number;
    /**
     * The ID of the token created
     * @type {number}
     * @memberof SDTokenGetResponse
     */
    'id': number;
    /**
     * The name of the template
     * @type {string}
     * @memberof SDTokenGetResponse
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof SDTokenGetResponse
     */
    'flags': number;
    /**
     * 
     * @type {SDTemplateGetTokensResponseTokenProps}
     * @memberof SDTokenGetResponse
     */
    'props': SDTemplateGetTokensResponseTokenProps;
    /**
     * Game Owner\'s Public Key
     * @type {string}
     * @memberof SDTokenGetResponse
     */
    'owner'?: string;
    /**
     * Returned to marketplaces as token metadata
     * @type {object}
     * @memberof SDTokenGetResponse
     */
    'publicMetadata'?: object;
}
/**
 * 
 * @export
 * @interface SDTokenMintBulkRequest
 */
export interface SDTokenMintBulkRequest {
    /**
     * The player ID that was returned from player/create
     * @type {string}
     * @memberof SDTokenMintBulkRequest
     */
    'playerId': string;
    /**
     * array of Token objects
     * @type {Array<SDTokenMintBulkTokenObject>}
     * @memberof SDTokenMintBulkRequest
     */
    'tokenObjects': Array<SDTokenMintBulkTokenObject>;
}
/**
 * 
 * @export
 * @interface SDTokenMintBulkTokenObject
 */
export interface SDTokenMintBulkTokenObject {
    /**
     * Specifies which Template you are creating an instance of (ex. 3)
     * @type {number}
     * @memberof SDTokenMintBulkTokenObject
     */
    'templateId': number;
    /**
     * u64 Number as String, min: 0, max: 9223372036854775807 (ex. \"6\")
     * @type {string}
     * @memberof SDTokenMintBulkTokenObject
     */
    'amount': string;
    /**
     * 
     * @type {SDTokenMintBulkTokenObjectProps}
     * @memberof SDTokenMintBulkTokenObject
     */
    'props'?: SDTokenMintBulkTokenObjectProps;
    /**
     * Returned to marketplaces as token metadata
     * @type {object}
     * @memberof SDTokenMintBulkTokenObject
     */
    'publicMetadata'?: object;
}
/**
 * Internal metadata
 * @export
 * @interface SDTokenMintBulkTokenObjectProps
 */
export interface SDTokenMintBulkTokenObjectProps {
    /**
     * Specifies which properties you want to add (ex. {prop1: 5, prop2: 6, prop3: 7})
     * @type {object}
     * @memberof SDTokenMintBulkTokenObjectProps
     */
    'mutable': object;
    /**
     * Specifies which properties you want to add (ex. {prop1: 5, prop2: 6, prop3: 7})
     * @type {object}
     * @memberof SDTokenMintBulkTokenObjectProps
     */
    'immutable'?: object;
}
/**
 * 
 * @export
 * @interface SDTokenMutateRequest
 */
export interface SDTokenMutateRequest {
    /**
     * Specifies which tokenId you want to manipulate (ex. 11)
     * @type {number}
     * @memberof SDTokenMutateRequest
     */
    'tokenId': number;
    /**
     * Specifies which properties you want to change (ex. {prop1: 5, prop2: 6, prop3: 7})
     * @type {object}
     * @memberof SDTokenMutateRequest
     */
    'props': object;
    /**
     * Returned to marketplaces as token metadata
     * @type {object}
     * @memberof SDTokenMutateRequest
     */
    'publicMetadata'?: object;
}
/**
 * 
 * @export
 * @interface SDTokenTransferRequest
 */
export interface SDTokenTransferRequest {
    /**
     * The Player\'s id, can be found with Player/getId(s). (ex. CzySggxVQz51jciGRFDY7d5BER2fav6TNEnPGjusPJPd)
     * @type {string}
     * @memberof SDTokenTransferRequest
     */
    'fromPlayerId': string;
    /**
     * The Player\'s id, can be found with Player/getId(s). (ex. 53ywNSVp46QpiA6S86DLLfeKVfjcSAFxHR2L9j8tnte2)
     * @type {string}
     * @memberof SDTokenTransferRequest
     */
    'toPlayerId': string;
    /**
     * An array of objects of which tokens to transfer (ex. [{tokenId: 5, amount: \"3\"}])
     * @type {Array<SDTokenBurnRequestTokenObjectsInner>}
     * @memberof SDTokenTransferRequest
     */
    'tokenObjects': Array<SDTokenBurnRequestTokenObjectsInner>;
}
/**
 * 
 * @export
 * @interface SDTokenWithdrawObject
 */
export interface SDTokenWithdrawObject {
    /**
     * 
     * @type {number}
     * @memberof SDTokenWithdrawObject
     */
    'tokenId': number;
    /**
     * u64 Number as String, min: 1, max: 9223372036854775807
     * @type {string}
     * @memberof SDTokenWithdrawObject
     */
    'amount': string;
}
/**
 * 
 * @export
 * @interface SDTokenWithdrawRequest
 */
export interface SDTokenWithdrawRequest {
    /**
     * External (non-custodial) blockchain wallet address
     * @type {string}
     * @memberof SDTokenWithdrawRequest
     */
    'address': string;
    /**
     * The Player\'s id, can be found with Player/getId(s) in uuid format. Also returned from player/create (ex. XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX)
     * @type {string}
     * @memberof SDTokenWithdrawRequest
     */
    'playerId': string;
    /**
     * Array of Token objects
     * @type {Array<SDTokenWithdrawObject>}
     * @memberof SDTokenWithdrawRequest
     */
    'tokenObjects': Array<SDTokenWithdrawObject>;
}

/**
 * GameEndpointsApi - axios parameter creator
 * @export
 */
export const GameEndpointsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the Details of Your Game
         * @summary Get Game
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameGetGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/game/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change a games data
         * @summary Mutate Game
         * @param {SDGameMutateRequest} sDGameMutateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameMutatePut: async (sDGameMutateRequest: SDGameMutateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sDGameMutateRequest' is not null or undefined
            assertParamExists('gameMutatePut', 'sDGameMutateRequest', sDGameMutateRequest)
            const localVarPath = `/game/mutate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sDGameMutateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GameEndpointsApi - functional programming interface
 * @export
 */
export const GameEndpointsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GameEndpointsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the Details of Your Game
         * @summary Get Game
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gameGetGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SDGameGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gameGetGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Change a games data
         * @summary Mutate Game
         * @param {SDGameMutateRequest} sDGameMutateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gameMutatePut(sDGameMutateRequest: SDGameMutateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gameMutatePut(sDGameMutateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * GameEndpointsApi - factory interface
 * @export
 */
export const GameEndpointsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GameEndpointsApiFp(configuration)
    return {
        /**
         * Get the Details of Your Game
         * @summary Get Game
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameGetGet(options?: any): AxiosPromise<SDGameGetResponse> {
            return localVarFp.gameGetGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Change a games data
         * @summary Mutate Game
         * @param {SDGameMutateRequest} sDGameMutateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gameMutatePut(sDGameMutateRequest: SDGameMutateRequest, options?: any): AxiosPromise<object> {
            return localVarFp.gameMutatePut(sDGameMutateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GameEndpointsApi - object-oriented interface
 * @export
 * @class GameEndpointsApi
 * @extends {BaseAPI}
 */
export class GameEndpointsApi extends BaseAPI {
    /**
     * Get the Details of Your Game
     * @summary Get Game
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameEndpointsApi
     */
    public gameGetGet(options?: AxiosRequestConfig) {
        return GameEndpointsApiFp(this.configuration).gameGetGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change a games data
     * @summary Mutate Game
     * @param {SDGameMutateRequest} sDGameMutateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GameEndpointsApi
     */
    public gameMutatePut(sDGameMutateRequest: SDGameMutateRequest, options?: AxiosRequestConfig) {
        return GameEndpointsApiFp(this.configuration).gameMutatePut(sDGameMutateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HealthEndpointsApi - axios parameter creator
 * @export
 */
export const HealthEndpointsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get system health info
         * @summary Get Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthEndpointsApi - functional programming interface
 * @export
 */
export const HealthEndpointsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthEndpointsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get system health info
         * @summary Get Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SDHealthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HealthEndpointsApi - factory interface
 * @export
 */
export const HealthEndpointsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthEndpointsApiFp(configuration)
    return {
        /**
         * Get system health info
         * @summary Get Health
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthGet(options?: any): AxiosPromise<SDHealthResponse> {
            return localVarFp.healthGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthEndpointsApi - object-oriented interface
 * @export
 * @class HealthEndpointsApi
 * @extends {BaseAPI}
 */
export class HealthEndpointsApi extends BaseAPI {
    /**
     * Get system health info
     * @summary Get Health
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthEndpointsApi
     */
    public healthGet(options?: AxiosRequestConfig) {
        return HealthEndpointsApiFp(this.configuration).healthGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrderEndpointsApi - axios parameter creator
 * @export
 */
export const OrderEndpointsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Buy a Order
         * @summary Buy Order
         * @param {SDOrderBuyRequest} sDOrderBuyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderBuyPost: async (sDOrderBuyRequest: SDOrderBuyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sDOrderBuyRequest' is not null or undefined
            assertParamExists('orderBuyPost', 'sDOrderBuyRequest', sDOrderBuyRequest)
            const localVarPath = `/order/buy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sDOrderBuyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancels a Order
         * @summary Cancel Order
         * @param {string} orderId Order Id unsigned 32 bit integer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderCancelDelete: async (orderId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('orderCancelDelete', 'orderId', orderId)
            const localVarPath = `/order/cancel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a New Order
         * @summary Create Order
         * @param {SDOrderCreateRequest} sDOrderCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderCreatePost: async (sDOrderCreateRequest: SDOrderCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sDOrderCreateRequest' is not null or undefined
            assertParamExists('orderCreatePost', 'sDOrderCreateRequest', sDOrderCreateRequest)
            const localVarPath = `/order/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sDOrderCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the List of Game Orders
         * @summary Get All Orders
         * @param {string} start position in list
         * @param {string} limit maximum templates returned in list
         * @param {string} [playerId] A Games PlayerId to filter by player
         * @param {string} [status] State of the order to filter. Default is offer. (\&#39;offer\&#39;, \&#39;accepted\&#39;, \&#39;cancelled\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGetAllGet: async (start: string, limit: string, playerId?: string, status?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'start' is not null or undefined
            assertParamExists('orderGetAllGet', 'start', start)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('orderGetAllGet', 'limit', limit)
            const localVarPath = `/order/get-all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (playerId !== undefined) {
                localVarQueryParameter['playerId'] = playerId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Game Order
         * @summary Get Order
         * @param {string} orderId An Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGetGet: async (orderId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('orderGetGet', 'orderId', orderId)
            const localVarPath = `/order/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderEndpointsApi - functional programming interface
 * @export
 */
export const OrderEndpointsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrderEndpointsApiAxiosParamCreator(configuration)
    return {
        /**
         * Buy a Order
         * @summary Buy Order
         * @param {SDOrderBuyRequest} sDOrderBuyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderBuyPost(sDOrderBuyRequest: SDOrderBuyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderBuyPost(sDOrderBuyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cancels a Order
         * @summary Cancel Order
         * @param {string} orderId Order Id unsigned 32 bit integer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderCancelDelete(orderId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderCancelDelete(orderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a New Order
         * @summary Create Order
         * @param {SDOrderCreateRequest} sDOrderCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderCreatePost(sDOrderCreateRequest: SDOrderCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SDOrderCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderCreatePost(sDOrderCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the List of Game Orders
         * @summary Get All Orders
         * @param {string} start position in list
         * @param {string} limit maximum templates returned in list
         * @param {string} [playerId] A Games PlayerId to filter by player
         * @param {string} [status] State of the order to filter. Default is offer. (\&#39;offer\&#39;, \&#39;accepted\&#39;, \&#39;cancelled\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderGetAllGet(start: string, limit: string, playerId?: string, status?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SDOrderGetAllResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderGetAllGet(start, limit, playerId, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a Game Order
         * @summary Get Order
         * @param {string} orderId An Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderGetGet(orderId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SDOrderGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderGetGet(orderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrderEndpointsApi - factory interface
 * @export
 */
export const OrderEndpointsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrderEndpointsApiFp(configuration)
    return {
        /**
         * Buy a Order
         * @summary Buy Order
         * @param {SDOrderBuyRequest} sDOrderBuyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderBuyPost(sDOrderBuyRequest: SDOrderBuyRequest, options?: any): AxiosPromise<object> {
            return localVarFp.orderBuyPost(sDOrderBuyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancels a Order
         * @summary Cancel Order
         * @param {string} orderId Order Id unsigned 32 bit integer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderCancelDelete(orderId: string, options?: any): AxiosPromise<object> {
            return localVarFp.orderCancelDelete(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a New Order
         * @summary Create Order
         * @param {SDOrderCreateRequest} sDOrderCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderCreatePost(sDOrderCreateRequest: SDOrderCreateRequest, options?: any): AxiosPromise<SDOrderCreateResponse> {
            return localVarFp.orderCreatePost(sDOrderCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the List of Game Orders
         * @summary Get All Orders
         * @param {string} start position in list
         * @param {string} limit maximum templates returned in list
         * @param {string} [playerId] A Games PlayerId to filter by player
         * @param {string} [status] State of the order to filter. Default is offer. (\&#39;offer\&#39;, \&#39;accepted\&#39;, \&#39;cancelled\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGetAllGet(start: string, limit: string, playerId?: string, status?: string, options?: any): AxiosPromise<Array<SDOrderGetAllResponse>> {
            return localVarFp.orderGetAllGet(start, limit, playerId, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Game Order
         * @summary Get Order
         * @param {string} orderId An Order ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGetGet(orderId: string, options?: any): AxiosPromise<SDOrderGetResponse> {
            return localVarFp.orderGetGet(orderId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrderEndpointsApi - object-oriented interface
 * @export
 * @class OrderEndpointsApi
 * @extends {BaseAPI}
 */
export class OrderEndpointsApi extends BaseAPI {
    /**
     * Buy a Order
     * @summary Buy Order
     * @param {SDOrderBuyRequest} sDOrderBuyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderEndpointsApi
     */
    public orderBuyPost(sDOrderBuyRequest: SDOrderBuyRequest, options?: AxiosRequestConfig) {
        return OrderEndpointsApiFp(this.configuration).orderBuyPost(sDOrderBuyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancels a Order
     * @summary Cancel Order
     * @param {string} orderId Order Id unsigned 32 bit integer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderEndpointsApi
     */
    public orderCancelDelete(orderId: string, options?: AxiosRequestConfig) {
        return OrderEndpointsApiFp(this.configuration).orderCancelDelete(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a New Order
     * @summary Create Order
     * @param {SDOrderCreateRequest} sDOrderCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderEndpointsApi
     */
    public orderCreatePost(sDOrderCreateRequest: SDOrderCreateRequest, options?: AxiosRequestConfig) {
        return OrderEndpointsApiFp(this.configuration).orderCreatePost(sDOrderCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the List of Game Orders
     * @summary Get All Orders
     * @param {string} start position in list
     * @param {string} limit maximum templates returned in list
     * @param {string} [playerId] A Games PlayerId to filter by player
     * @param {string} [status] State of the order to filter. Default is offer. (\&#39;offer\&#39;, \&#39;accepted\&#39;, \&#39;cancelled\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderEndpointsApi
     */
    public orderGetAllGet(start: string, limit: string, playerId?: string, status?: string, options?: AxiosRequestConfig) {
        return OrderEndpointsApiFp(this.configuration).orderGetAllGet(start, limit, playerId, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Game Order
     * @summary Get Order
     * @param {string} orderId An Order ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderEndpointsApi
     */
    public orderGetGet(orderId: string, options?: AxiosRequestConfig) {
        return OrderEndpointsApiFp(this.configuration).orderGetGet(orderId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PlayerEndpointsApi - axios parameter creator
 * @export
 */
export const PlayerEndpointsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get Player count within a game
         * @summary Get Player Count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerCountGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/player/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Player for a game. Returns their player id which can be used to reference them later in Stardust\'s system
         * @summary Create Player
         * @param {SDPlayerCreateRequest} sDPlayerCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerCreatePost: async (sDPlayerCreateRequest: SDPlayerCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sDPlayerCreateRequest' is not null or undefined
            assertParamExists('playerCreatePost', 'sDPlayerCreateRequest', sDPlayerCreateRequest)
            const localVarPath = `/player/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sDPlayerCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the List of All Players in Game
         * @summary Get All Players
         * @param {string} [start] position in list
         * @param {string} [filter] Find a substring within the Player unique ID field
         * @param {string} [limit] maximum items returned in list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerGetAllGet: async (start?: string, filter?: string, limit?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/player/get-all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Details of a Player Within a Game
         * @summary Get Player
         * @param {string} playerId Player id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerGetGet: async (playerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'playerId' is not null or undefined
            assertParamExists('playerGetGet', 'playerId', playerId)
            const localVarPath = `/player/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (playerId !== undefined) {
                localVarQueryParameter['playerId'] = playerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Player\'s ID via their Unique ID
         * @summary Get Player ID
         * @param {string} uniqueId Player\&#39;s Unique ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerGetIdGet: async (uniqueId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uniqueId' is not null or undefined
            assertParamExists('playerGetIdGet', 'uniqueId', uniqueId)
            const localVarPath = `/player/get-id`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (uniqueId !== undefined) {
                localVarQueryParameter['uniqueId'] = uniqueId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get All Player IDs for a Given Game
         * @summary Get All Player IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerGetIdsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/player/get-ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a players inventory and all the items it holds
         * @summary Get Player Inventory
         * @param {string} playerId Player id
         * @param {string} [start] position in list
         * @param {string} [tokenIds] Comma-Separated String of token ids (ex. \&#39;3589, 3580\&#39;)
         * @param {string} [limit] maximum items returned in list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerGetInventoryGet: async (playerId: string, start?: string, tokenIds?: string, limit?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'playerId' is not null or undefined
            assertParamExists('playerGetInventoryGet', 'playerId', playerId)
            const localVarPath = `/player/get-inventory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (tokenIds !== undefined) {
                localVarQueryParameter['tokenIds'] = tokenIds;
            }

            if (playerId !== undefined) {
                localVarQueryParameter['playerId'] = playerId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change player data
         * @summary Mutate Player
         * @param {SDPlayerMutateRequest} sDPlayerMutateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerMutatePut: async (sDPlayerMutateRequest: SDPlayerMutateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sDPlayerMutateRequest' is not null or undefined
            assertParamExists('playerMutatePut', 'sDPlayerMutateRequest', sDPlayerMutateRequest)
            const localVarPath = `/player/mutate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sDPlayerMutateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes (hides) a player from your game. This is not permanent.
         * @summary Remove Player
         * @param {string} playerId Player Id returned from player/create a UUID, i.e. 802760b0-2bb5-4fba-9237-895ed02cf8d8
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerRemoveDelete: async (playerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'playerId' is not null or undefined
            assertParamExists('playerRemoveDelete', 'playerId', playerId)
            const localVarPath = `/player/remove`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (playerId !== undefined) {
                localVarQueryParameter['playerId'] = playerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get player\'s wallet within a game
         * @summary Get Player Wallet
         * @param {string} playerId Player id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerWalletGetGet: async (playerId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'playerId' is not null or undefined
            assertParamExists('playerWalletGetGet', 'playerId', playerId)
            const localVarPath = `/player/wallet-get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (playerId !== undefined) {
                localVarQueryParameter['playerId'] = playerId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Withdraw a Player\'s Tokens from their Stardust Wallet
         * @summary Withdraw From Player
         * @param {SDPlayerWithdrawRequest} sDPlayerWithdrawRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerWithdrawPost: async (sDPlayerWithdrawRequest: SDPlayerWithdrawRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sDPlayerWithdrawRequest' is not null or undefined
            assertParamExists('playerWithdrawPost', 'sDPlayerWithdrawRequest', sDPlayerWithdrawRequest)
            const localVarPath = `/player/withdraw`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sDPlayerWithdrawRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlayerEndpointsApi - functional programming interface
 * @export
 */
export const PlayerEndpointsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlayerEndpointsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get Player count within a game
         * @summary Get Player Count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playerCountGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SDPlayerCountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playerCountGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a Player for a game. Returns their player id which can be used to reference them later in Stardust\'s system
         * @summary Create Player
         * @param {SDPlayerCreateRequest} sDPlayerCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playerCreatePost(sDPlayerCreateRequest: SDPlayerCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SDPlayerCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playerCreatePost(sDPlayerCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the List of All Players in Game
         * @summary Get All Players
         * @param {string} [start] position in list
         * @param {string} [filter] Find a substring within the Player unique ID field
         * @param {string} [limit] maximum items returned in list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playerGetAllGet(start?: string, filter?: string, limit?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SDPlayerGetAllResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playerGetAllGet(start, filter, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get Details of a Player Within a Game
         * @summary Get Player
         * @param {string} playerId Player id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playerGetGet(playerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SDPlayerGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playerGetGet(playerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a Player\'s ID via their Unique ID
         * @summary Get Player ID
         * @param {string} uniqueId Player\&#39;s Unique ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playerGetIdGet(uniqueId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SDPlayerGetIdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playerGetIdGet(uniqueId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get All Player IDs for a Given Game
         * @summary Get All Player IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playerGetIdsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SDPlayerGetIdsResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playerGetIdsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a players inventory and all the items it holds
         * @summary Get Player Inventory
         * @param {string} playerId Player id
         * @param {string} [start] position in list
         * @param {string} [tokenIds] Comma-Separated String of token ids (ex. \&#39;3589, 3580\&#39;)
         * @param {string} [limit] maximum items returned in list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playerGetInventoryGet(playerId: string, start?: string, tokenIds?: string, limit?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SDPlayerGetInventoryResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playerGetInventoryGet(playerId, start, tokenIds, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Change player data
         * @summary Mutate Player
         * @param {SDPlayerMutateRequest} sDPlayerMutateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playerMutatePut(sDPlayerMutateRequest: SDPlayerMutateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playerMutatePut(sDPlayerMutateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes (hides) a player from your game. This is not permanent.
         * @summary Remove Player
         * @param {string} playerId Player Id returned from player/create a UUID, i.e. 802760b0-2bb5-4fba-9237-895ed02cf8d8
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playerRemoveDelete(playerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playerRemoveDelete(playerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get player\'s wallet within a game
         * @summary Get Player Wallet
         * @param {string} playerId Player id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playerWalletGetGet(playerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SDPlayerWalletGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playerWalletGetGet(playerId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Withdraw a Player\'s Tokens from their Stardust Wallet
         * @summary Withdraw From Player
         * @param {SDPlayerWithdrawRequest} sDPlayerWithdrawRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async playerWithdrawPost(sDPlayerWithdrawRequest: SDPlayerWithdrawRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.playerWithdrawPost(sDPlayerWithdrawRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PlayerEndpointsApi - factory interface
 * @export
 */
export const PlayerEndpointsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlayerEndpointsApiFp(configuration)
    return {
        /**
         * Get Player count within a game
         * @summary Get Player Count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerCountGet(options?: any): AxiosPromise<SDPlayerCountResponse> {
            return localVarFp.playerCountGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Create a Player for a game. Returns their player id which can be used to reference them later in Stardust\'s system
         * @summary Create Player
         * @param {SDPlayerCreateRequest} sDPlayerCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerCreatePost(sDPlayerCreateRequest: SDPlayerCreateRequest, options?: any): AxiosPromise<SDPlayerCreateResponse> {
            return localVarFp.playerCreatePost(sDPlayerCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the List of All Players in Game
         * @summary Get All Players
         * @param {string} [start] position in list
         * @param {string} [filter] Find a substring within the Player unique ID field
         * @param {string} [limit] maximum items returned in list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerGetAllGet(start?: string, filter?: string, limit?: string, options?: any): AxiosPromise<Array<SDPlayerGetAllResponse>> {
            return localVarFp.playerGetAllGet(start, filter, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Details of a Player Within a Game
         * @summary Get Player
         * @param {string} playerId Player id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerGetGet(playerId: string, options?: any): AxiosPromise<SDPlayerGetResponse> {
            return localVarFp.playerGetGet(playerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Player\'s ID via their Unique ID
         * @summary Get Player ID
         * @param {string} uniqueId Player\&#39;s Unique ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerGetIdGet(uniqueId: string, options?: any): AxiosPromise<SDPlayerGetIdResponse> {
            return localVarFp.playerGetIdGet(uniqueId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get All Player IDs for a Given Game
         * @summary Get All Player IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerGetIdsGet(options?: any): AxiosPromise<Array<SDPlayerGetIdsResponse>> {
            return localVarFp.playerGetIdsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a players inventory and all the items it holds
         * @summary Get Player Inventory
         * @param {string} playerId Player id
         * @param {string} [start] position in list
         * @param {string} [tokenIds] Comma-Separated String of token ids (ex. \&#39;3589, 3580\&#39;)
         * @param {string} [limit] maximum items returned in list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerGetInventoryGet(playerId: string, start?: string, tokenIds?: string, limit?: string, options?: any): AxiosPromise<Array<SDPlayerGetInventoryResponse>> {
            return localVarFp.playerGetInventoryGet(playerId, start, tokenIds, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Change player data
         * @summary Mutate Player
         * @param {SDPlayerMutateRequest} sDPlayerMutateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerMutatePut(sDPlayerMutateRequest: SDPlayerMutateRequest, options?: any): AxiosPromise<object> {
            return localVarFp.playerMutatePut(sDPlayerMutateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes (hides) a player from your game. This is not permanent.
         * @summary Remove Player
         * @param {string} playerId Player Id returned from player/create a UUID, i.e. 802760b0-2bb5-4fba-9237-895ed02cf8d8
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerRemoveDelete(playerId: string, options?: any): AxiosPromise<object> {
            return localVarFp.playerRemoveDelete(playerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get player\'s wallet within a game
         * @summary Get Player Wallet
         * @param {string} playerId Player id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerWalletGetGet(playerId: string, options?: any): AxiosPromise<SDPlayerWalletGetResponse> {
            return localVarFp.playerWalletGetGet(playerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Withdraw a Player\'s Tokens from their Stardust Wallet
         * @summary Withdraw From Player
         * @param {SDPlayerWithdrawRequest} sDPlayerWithdrawRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        playerWithdrawPost(sDPlayerWithdrawRequest: SDPlayerWithdrawRequest, options?: any): AxiosPromise<object> {
            return localVarFp.playerWithdrawPost(sDPlayerWithdrawRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PlayerEndpointsApi - object-oriented interface
 * @export
 * @class PlayerEndpointsApi
 * @extends {BaseAPI}
 */
export class PlayerEndpointsApi extends BaseAPI {
    /**
     * Get Player count within a game
     * @summary Get Player Count
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerEndpointsApi
     */
    public playerCountGet(options?: AxiosRequestConfig) {
        return PlayerEndpointsApiFp(this.configuration).playerCountGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a Player for a game. Returns their player id which can be used to reference them later in Stardust\'s system
     * @summary Create Player
     * @param {SDPlayerCreateRequest} sDPlayerCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerEndpointsApi
     */
    public playerCreatePost(sDPlayerCreateRequest: SDPlayerCreateRequest, options?: AxiosRequestConfig) {
        return PlayerEndpointsApiFp(this.configuration).playerCreatePost(sDPlayerCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the List of All Players in Game
     * @summary Get All Players
     * @param {string} [start] position in list
     * @param {string} [filter] Find a substring within the Player unique ID field
     * @param {string} [limit] maximum items returned in list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerEndpointsApi
     */
    public playerGetAllGet(start?: string, filter?: string, limit?: string, options?: AxiosRequestConfig) {
        return PlayerEndpointsApiFp(this.configuration).playerGetAllGet(start, filter, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Details of a Player Within a Game
     * @summary Get Player
     * @param {string} playerId Player id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerEndpointsApi
     */
    public playerGetGet(playerId: string, options?: AxiosRequestConfig) {
        return PlayerEndpointsApiFp(this.configuration).playerGetGet(playerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Player\'s ID via their Unique ID
     * @summary Get Player ID
     * @param {string} uniqueId Player\&#39;s Unique ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerEndpointsApi
     */
    public playerGetIdGet(uniqueId: string, options?: AxiosRequestConfig) {
        return PlayerEndpointsApiFp(this.configuration).playerGetIdGet(uniqueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get All Player IDs for a Given Game
     * @summary Get All Player IDs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerEndpointsApi
     */
    public playerGetIdsGet(options?: AxiosRequestConfig) {
        return PlayerEndpointsApiFp(this.configuration).playerGetIdsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a players inventory and all the items it holds
     * @summary Get Player Inventory
     * @param {string} playerId Player id
     * @param {string} [start] position in list
     * @param {string} [tokenIds] Comma-Separated String of token ids (ex. \&#39;3589, 3580\&#39;)
     * @param {string} [limit] maximum items returned in list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerEndpointsApi
     */
    public playerGetInventoryGet(playerId: string, start?: string, tokenIds?: string, limit?: string, options?: AxiosRequestConfig) {
        return PlayerEndpointsApiFp(this.configuration).playerGetInventoryGet(playerId, start, tokenIds, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Change player data
     * @summary Mutate Player
     * @param {SDPlayerMutateRequest} sDPlayerMutateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerEndpointsApi
     */
    public playerMutatePut(sDPlayerMutateRequest: SDPlayerMutateRequest, options?: AxiosRequestConfig) {
        return PlayerEndpointsApiFp(this.configuration).playerMutatePut(sDPlayerMutateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes (hides) a player from your game. This is not permanent.
     * @summary Remove Player
     * @param {string} playerId Player Id returned from player/create a UUID, i.e. 802760b0-2bb5-4fba-9237-895ed02cf8d8
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerEndpointsApi
     */
    public playerRemoveDelete(playerId: string, options?: AxiosRequestConfig) {
        return PlayerEndpointsApiFp(this.configuration).playerRemoveDelete(playerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get player\'s wallet within a game
     * @summary Get Player Wallet
     * @param {string} playerId Player id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerEndpointsApi
     */
    public playerWalletGetGet(playerId: string, options?: AxiosRequestConfig) {
        return PlayerEndpointsApiFp(this.configuration).playerWalletGetGet(playerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Withdraw a Player\'s Tokens from their Stardust Wallet
     * @summary Withdraw From Player
     * @param {SDPlayerWithdrawRequest} sDPlayerWithdrawRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlayerEndpointsApi
     */
    public playerWithdrawPost(sDPlayerWithdrawRequest: SDPlayerWithdrawRequest, options?: AxiosRequestConfig) {
        return PlayerEndpointsApiFp(this.configuration).playerWithdrawPost(sDPlayerWithdrawRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TemplateEndpointsApi - axios parameter creator
 * @export
 */
export const TemplateEndpointsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a Template\'s Count Within a Game
         * @summary Get Template Count
         * @param {string} [filter] Find a substring within the Template name field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateCountGet: async (filter?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/template/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds a New Token Template that lets Players Acquire that Token using the Token/Mint Endpoint
         * @summary Create Template
         * @param {SDTemplateCreateRequest} sDTemplateCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateCreatePost: async (sDTemplateCreateRequest: SDTemplateCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sDTemplateCreateRequest' is not null or undefined
            assertParamExists('templateCreatePost', 'sDTemplateCreateRequest', sDTemplateCreateRequest)
            const localVarPath = `/template/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sDTemplateCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get All of the Templates Within a Game
         * @summary Get All Templates
         * @param {string} start position in list
         * @param {string} limit maximum templates returned in list
         * @param {string} [filter] Find a substring within the Template name field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateGetAllGet: async (start: string, limit: string, filter?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'start' is not null or undefined
            assertParamExists('templateGetAllGet', 'start', start)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('templateGetAllGet', 'limit', limit)
            const localVarPath = `/template/get-all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the Details of a Template
         * @summary Get Template
         * @param {string} templateId Template Id such as 3589)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateGetGet: async (templateId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('templateGetGet', 'templateId', templateId)
            const localVarPath = `/template/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (templateId !== undefined) {
                localVarQueryParameter['templateId'] = templateId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a List of All Minted Tokens from a Given Template
         * @summary Get Template Tokens
         * @param {string} templateId The ID of the Template
         * @param {string} [start] position in list
         * @param {string} [limit] maximum templates returned in list
         * @param {string} [includeDeleted] If true tokens from deleted players are included in the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateGetTokensGet: async (templateId: string, start?: string, limit?: string, includeDeleted?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('templateGetTokensGet', 'templateId', templateId)
            const localVarPath = `/template/get-tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (templateId !== undefined) {
                localVarQueryParameter['templateId'] = templateId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (includeDeleted !== undefined) {
                localVarQueryParameter['includeDeleted'] = includeDeleted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mutates a Property of a Template, Which in Turn will Affect the Inherited Property on All of the Tokens Created from this Template (via token/mint)
         * @summary Mutate Template
         * @param {SDTemplateMutateRequest} sDTemplateMutateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateMutatePut: async (sDTemplateMutateRequest: SDTemplateMutateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sDTemplateMutateRequest' is not null or undefined
            assertParamExists('templateMutatePut', 'sDTemplateMutateRequest', sDTemplateMutateRequest)
            const localVarPath = `/template/mutate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sDTemplateMutateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a Templates Property from Your Game
         * @summary Remove Template Property
         * @param {string} templateId Template Id returned from template/create (ex. 5)
         * @param {string} props Stringify Array of template mutable property names ex: \&#39;[\&quot;exp\&quot;, \&quot;health\&quot;]\&#39; }
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatePropsRemoveDelete: async (templateId: string, props: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('templatePropsRemoveDelete', 'templateId', templateId)
            // verify required parameter 'props' is not null or undefined
            assertParamExists('templatePropsRemoveDelete', 'props', props)
            const localVarPath = `/template/props-remove`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (templateId !== undefined) {
                localVarQueryParameter['templateId'] = templateId;
            }

            if (props !== undefined) {
                localVarQueryParameter['props'] = props;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a Template from Your Game. If Players have Instances of this Template from the token/mint Command, Their Tokens will NOT be Removed
         * @summary Remove Template
         * @param {string} templateId Template Id returned from template/create (ex. 5)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateRemoveDelete: async (templateId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('templateRemoveDelete', 'templateId', templateId)
            const localVarPath = `/template/remove`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (templateId !== undefined) {
                localVarQueryParameter['templateId'] = templateId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TemplateEndpointsApi - functional programming interface
 * @export
 */
export const TemplateEndpointsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TemplateEndpointsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a Template\'s Count Within a Game
         * @summary Get Template Count
         * @param {string} [filter] Find a substring within the Template name field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templateCountGet(filter?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SDTemplateCountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templateCountGet(filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds a New Token Template that lets Players Acquire that Token using the Token/Mint Endpoint
         * @summary Create Template
         * @param {SDTemplateCreateRequest} sDTemplateCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templateCreatePost(sDTemplateCreateRequest: SDTemplateCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SDTemplateCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templateCreatePost(sDTemplateCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get All of the Templates Within a Game
         * @summary Get All Templates
         * @param {string} start position in list
         * @param {string} limit maximum templates returned in list
         * @param {string} [filter] Find a substring within the Template name field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templateGetAllGet(start: string, limit: string, filter?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SDTemplateGetAllResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templateGetAllGet(start, limit, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the Details of a Template
         * @summary Get Template
         * @param {string} templateId Template Id such as 3589)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templateGetGet(templateId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SDTemplateGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templateGetGet(templateId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a List of All Minted Tokens from a Given Template
         * @summary Get Template Tokens
         * @param {string} templateId The ID of the Template
         * @param {string} [start] position in list
         * @param {string} [limit] maximum templates returned in list
         * @param {string} [includeDeleted] If true tokens from deleted players are included in the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templateGetTokensGet(templateId: string, start?: string, limit?: string, includeDeleted?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SDTemplateGetTokensResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templateGetTokensGet(templateId, start, limit, includeDeleted, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mutates a Property of a Template, Which in Turn will Affect the Inherited Property on All of the Tokens Created from this Template (via token/mint)
         * @summary Mutate Template
         * @param {SDTemplateMutateRequest} sDTemplateMutateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templateMutatePut(sDTemplateMutateRequest: SDTemplateMutateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templateMutatePut(sDTemplateMutateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes a Templates Property from Your Game
         * @summary Remove Template Property
         * @param {string} templateId Template Id returned from template/create (ex. 5)
         * @param {string} props Stringify Array of template mutable property names ex: \&#39;[\&quot;exp\&quot;, \&quot;health\&quot;]\&#39; }
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templatePropsRemoveDelete(templateId: string, props: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templatePropsRemoveDelete(templateId, props, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes a Template from Your Game. If Players have Instances of this Template from the token/mint Command, Their Tokens will NOT be Removed
         * @summary Remove Template
         * @param {string} templateId Template Id returned from template/create (ex. 5)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templateRemoveDelete(templateId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templateRemoveDelete(templateId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TemplateEndpointsApi - factory interface
 * @export
 */
export const TemplateEndpointsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TemplateEndpointsApiFp(configuration)
    return {
        /**
         * Get a Template\'s Count Within a Game
         * @summary Get Template Count
         * @param {string} [filter] Find a substring within the Template name field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateCountGet(filter?: string, options?: any): AxiosPromise<SDTemplateCountResponse> {
            return localVarFp.templateCountGet(filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds a New Token Template that lets Players Acquire that Token using the Token/Mint Endpoint
         * @summary Create Template
         * @param {SDTemplateCreateRequest} sDTemplateCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateCreatePost(sDTemplateCreateRequest: SDTemplateCreateRequest, options?: any): AxiosPromise<SDTemplateCreateResponse> {
            return localVarFp.templateCreatePost(sDTemplateCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get All of the Templates Within a Game
         * @summary Get All Templates
         * @param {string} start position in list
         * @param {string} limit maximum templates returned in list
         * @param {string} [filter] Find a substring within the Template name field
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateGetAllGet(start: string, limit: string, filter?: string, options?: any): AxiosPromise<Array<SDTemplateGetAllResponse>> {
            return localVarFp.templateGetAllGet(start, limit, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the Details of a Template
         * @summary Get Template
         * @param {string} templateId Template Id such as 3589)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateGetGet(templateId: string, options?: any): AxiosPromise<SDTemplateGetResponse> {
            return localVarFp.templateGetGet(templateId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a List of All Minted Tokens from a Given Template
         * @summary Get Template Tokens
         * @param {string} templateId The ID of the Template
         * @param {string} [start] position in list
         * @param {string} [limit] maximum templates returned in list
         * @param {string} [includeDeleted] If true tokens from deleted players are included in the response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateGetTokensGet(templateId: string, start?: string, limit?: string, includeDeleted?: string, options?: any): AxiosPromise<Array<SDTemplateGetTokensResponse>> {
            return localVarFp.templateGetTokensGet(templateId, start, limit, includeDeleted, options).then((request) => request(axios, basePath));
        },
        /**
         * Mutates a Property of a Template, Which in Turn will Affect the Inherited Property on All of the Tokens Created from this Template (via token/mint)
         * @summary Mutate Template
         * @param {SDTemplateMutateRequest} sDTemplateMutateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateMutatePut(sDTemplateMutateRequest: SDTemplateMutateRequest, options?: any): AxiosPromise<object> {
            return localVarFp.templateMutatePut(sDTemplateMutateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a Templates Property from Your Game
         * @summary Remove Template Property
         * @param {string} templateId Template Id returned from template/create (ex. 5)
         * @param {string} props Stringify Array of template mutable property names ex: \&#39;[\&quot;exp\&quot;, \&quot;health\&quot;]\&#39; }
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatePropsRemoveDelete(templateId: string, props: string, options?: any): AxiosPromise<object> {
            return localVarFp.templatePropsRemoveDelete(templateId, props, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a Template from Your Game. If Players have Instances of this Template from the token/mint Command, Their Tokens will NOT be Removed
         * @summary Remove Template
         * @param {string} templateId Template Id returned from template/create (ex. 5)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateRemoveDelete(templateId: string, options?: any): AxiosPromise<object> {
            return localVarFp.templateRemoveDelete(templateId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TemplateEndpointsApi - object-oriented interface
 * @export
 * @class TemplateEndpointsApi
 * @extends {BaseAPI}
 */
export class TemplateEndpointsApi extends BaseAPI {
    /**
     * Get a Template\'s Count Within a Game
     * @summary Get Template Count
     * @param {string} [filter] Find a substring within the Template name field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateEndpointsApi
     */
    public templateCountGet(filter?: string, options?: AxiosRequestConfig) {
        return TemplateEndpointsApiFp(this.configuration).templateCountGet(filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds a New Token Template that lets Players Acquire that Token using the Token/Mint Endpoint
     * @summary Create Template
     * @param {SDTemplateCreateRequest} sDTemplateCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateEndpointsApi
     */
    public templateCreatePost(sDTemplateCreateRequest: SDTemplateCreateRequest, options?: AxiosRequestConfig) {
        return TemplateEndpointsApiFp(this.configuration).templateCreatePost(sDTemplateCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get All of the Templates Within a Game
     * @summary Get All Templates
     * @param {string} start position in list
     * @param {string} limit maximum templates returned in list
     * @param {string} [filter] Find a substring within the Template name field
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateEndpointsApi
     */
    public templateGetAllGet(start: string, limit: string, filter?: string, options?: AxiosRequestConfig) {
        return TemplateEndpointsApiFp(this.configuration).templateGetAllGet(start, limit, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the Details of a Template
     * @summary Get Template
     * @param {string} templateId Template Id such as 3589)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateEndpointsApi
     */
    public templateGetGet(templateId: string, options?: AxiosRequestConfig) {
        return TemplateEndpointsApiFp(this.configuration).templateGetGet(templateId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a List of All Minted Tokens from a Given Template
     * @summary Get Template Tokens
     * @param {string} templateId The ID of the Template
     * @param {string} [start] position in list
     * @param {string} [limit] maximum templates returned in list
     * @param {string} [includeDeleted] If true tokens from deleted players are included in the response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateEndpointsApi
     */
    public templateGetTokensGet(templateId: string, start?: string, limit?: string, includeDeleted?: string, options?: AxiosRequestConfig) {
        return TemplateEndpointsApiFp(this.configuration).templateGetTokensGet(templateId, start, limit, includeDeleted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mutates a Property of a Template, Which in Turn will Affect the Inherited Property on All of the Tokens Created from this Template (via token/mint)
     * @summary Mutate Template
     * @param {SDTemplateMutateRequest} sDTemplateMutateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateEndpointsApi
     */
    public templateMutatePut(sDTemplateMutateRequest: SDTemplateMutateRequest, options?: AxiosRequestConfig) {
        return TemplateEndpointsApiFp(this.configuration).templateMutatePut(sDTemplateMutateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a Templates Property from Your Game
     * @summary Remove Template Property
     * @param {string} templateId Template Id returned from template/create (ex. 5)
     * @param {string} props Stringify Array of template mutable property names ex: \&#39;[\&quot;exp\&quot;, \&quot;health\&quot;]\&#39; }
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateEndpointsApi
     */
    public templatePropsRemoveDelete(templateId: string, props: string, options?: AxiosRequestConfig) {
        return TemplateEndpointsApiFp(this.configuration).templatePropsRemoveDelete(templateId, props, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a Template from Your Game. If Players have Instances of this Template from the token/mint Command, Their Tokens will NOT be Removed
     * @summary Remove Template
     * @param {string} templateId Template Id returned from template/create (ex. 5)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateEndpointsApi
     */
    public templateRemoveDelete(templateId: string, options?: AxiosRequestConfig) {
        return TemplateEndpointsApiFp(this.configuration).templateRemoveDelete(templateId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TokenEndpointsApi - axios parameter creator
 * @export
 */
export const TokenEndpointsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Burns token on-chain. Cannot be reversed.
         * @summary Burn Token
         * @param {SDTokenBurnRequest} sDTokenBurnRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenBurnPost: async (sDTokenBurnRequest: SDTokenBurnRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sDTokenBurnRequest' is not null or undefined
            assertParamExists('tokenBurnPost', 'sDTokenBurnRequest', sDTokenBurnRequest)
            const localVarPath = `/token/burn`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sDTokenBurnRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Some of the details of this token are based upon the Template that it was created from (using token/mint)
         * @summary Get Token
         * @param {string} tokenIds Stringify Array of token ids (ex. \&#39;[3589, 3580]\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenGetGet: async (tokenIds: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenIds' is not null or undefined
            assertParamExists('tokenGetGet', 'tokenIds', tokenIds)
            const localVarPath = `/token/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (tokenIds !== undefined) {
                localVarQueryParameter['tokenIds'] = tokenIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mint tokens to a player
         * @summary Mint Tokens
         * @param {SDTokenMintBulkRequest} sDTokenMintBulkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenMintBulkPost: async (sDTokenMintBulkRequest: SDTokenMintBulkRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sDTokenMintBulkRequest' is not null or undefined
            assertParamExists('tokenMintBulkPost', 'sDTokenMintBulkRequest', sDTokenMintBulkRequest)
            const localVarPath = `/token/mint-bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sDTokenMintBulkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mutates a Property of a Token
         * @summary Mutate Token
         * @param {SDTokenMutateRequest} sDTokenMutateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenMutatePut: async (sDTokenMutateRequest: SDTokenMutateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sDTokenMutateRequest' is not null or undefined
            assertParamExists('tokenMutatePut', 'sDTokenMutateRequest', sDTokenMutateRequest)
            const localVarPath = `/token/mutate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sDTokenMutateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a Tokens Property from Your Game
         * @summary Remove Token Property
         * @param {string} tokenId Token Id returned from token/create (ex. 5)
         * @param {string} props Stringify Array of token mutable property names ex: \&#39;[\&quot;exp\&quot;, \&quot;health\&quot;]\&#39; }
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenPropsRemoveDelete: async (tokenId: string, props: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenId' is not null or undefined
            assertParamExists('tokenPropsRemoveDelete', 'tokenId', tokenId)
            // verify required parameter 'props' is not null or undefined
            assertParamExists('tokenPropsRemoveDelete', 'props', props)
            const localVarPath = `/token/props-remove`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (tokenId !== undefined) {
                localVarQueryParameter['tokenId'] = tokenId;
            }

            if (props !== undefined) {
                localVarQueryParameter['props'] = props;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this Endpoint to Facilitate Moving Tokens from one Player to Another
         * @summary Transfer Tokens
         * @param {SDTokenTransferRequest} sDTokenTransferRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenTransferPost: async (sDTokenTransferRequest: SDTokenTransferRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sDTokenTransferRequest' is not null or undefined
            assertParamExists('tokenTransferPost', 'sDTokenTransferRequest', sDTokenTransferRequest)
            const localVarPath = `/token/transfer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sDTokenTransferRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Withdraw tokens from a Stardust Wallet
         * @summary Withdraw Token
         * @param {SDTokenWithdrawRequest} sDTokenWithdrawRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenWithdrawPost: async (sDTokenWithdrawRequest: SDTokenWithdrawRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sDTokenWithdrawRequest' is not null or undefined
            assertParamExists('tokenWithdrawPost', 'sDTokenWithdrawRequest', sDTokenWithdrawRequest)
            const localVarPath = `/token/withdraw`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sDTokenWithdrawRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokenEndpointsApi - functional programming interface
 * @export
 */
export const TokenEndpointsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TokenEndpointsApiAxiosParamCreator(configuration)
    return {
        /**
         * Burns token on-chain. Cannot be reversed.
         * @summary Burn Token
         * @param {SDTokenBurnRequest} sDTokenBurnRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenBurnPost(sDTokenBurnRequest: SDTokenBurnRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenBurnPost(sDTokenBurnRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Some of the details of this token are based upon the Template that it was created from (using token/mint)
         * @summary Get Token
         * @param {string} tokenIds Stringify Array of token ids (ex. \&#39;[3589, 3580]\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenGetGet(tokenIds: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SDTokenGetResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenGetGet(tokenIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mint tokens to a player
         * @summary Mint Tokens
         * @param {SDTokenMintBulkRequest} sDTokenMintBulkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenMintBulkPost(sDTokenMintBulkRequest: SDTokenMintBulkRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenMintBulkPost(sDTokenMintBulkRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mutates a Property of a Token
         * @summary Mutate Token
         * @param {SDTokenMutateRequest} sDTokenMutateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenMutatePut(sDTokenMutateRequest: SDTokenMutateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenMutatePut(sDTokenMutateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes a Tokens Property from Your Game
         * @summary Remove Token Property
         * @param {string} tokenId Token Id returned from token/create (ex. 5)
         * @param {string} props Stringify Array of token mutable property names ex: \&#39;[\&quot;exp\&quot;, \&quot;health\&quot;]\&#39; }
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenPropsRemoveDelete(tokenId: string, props: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenPropsRemoveDelete(tokenId, props, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Use this Endpoint to Facilitate Moving Tokens from one Player to Another
         * @summary Transfer Tokens
         * @param {SDTokenTransferRequest} sDTokenTransferRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenTransferPost(sDTokenTransferRequest: SDTokenTransferRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenTransferPost(sDTokenTransferRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Withdraw tokens from a Stardust Wallet
         * @summary Withdraw Token
         * @param {SDTokenWithdrawRequest} sDTokenWithdrawRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenWithdrawPost(sDTokenWithdrawRequest: SDTokenWithdrawRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenWithdrawPost(sDTokenWithdrawRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TokenEndpointsApi - factory interface
 * @export
 */
export const TokenEndpointsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TokenEndpointsApiFp(configuration)
    return {
        /**
         * Burns token on-chain. Cannot be reversed.
         * @summary Burn Token
         * @param {SDTokenBurnRequest} sDTokenBurnRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenBurnPost(sDTokenBurnRequest: SDTokenBurnRequest, options?: any): AxiosPromise<object> {
            return localVarFp.tokenBurnPost(sDTokenBurnRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Some of the details of this token are based upon the Template that it was created from (using token/mint)
         * @summary Get Token
         * @param {string} tokenIds Stringify Array of token ids (ex. \&#39;[3589, 3580]\&#39;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenGetGet(tokenIds: string, options?: any): AxiosPromise<Array<SDTokenGetResponse>> {
            return localVarFp.tokenGetGet(tokenIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Mint tokens to a player
         * @summary Mint Tokens
         * @param {SDTokenMintBulkRequest} sDTokenMintBulkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenMintBulkPost(sDTokenMintBulkRequest: SDTokenMintBulkRequest, options?: any): AxiosPromise<Array<number>> {
            return localVarFp.tokenMintBulkPost(sDTokenMintBulkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Mutates a Property of a Token
         * @summary Mutate Token
         * @param {SDTokenMutateRequest} sDTokenMutateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenMutatePut(sDTokenMutateRequest: SDTokenMutateRequest, options?: any): AxiosPromise<object> {
            return localVarFp.tokenMutatePut(sDTokenMutateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes a Tokens Property from Your Game
         * @summary Remove Token Property
         * @param {string} tokenId Token Id returned from token/create (ex. 5)
         * @param {string} props Stringify Array of token mutable property names ex: \&#39;[\&quot;exp\&quot;, \&quot;health\&quot;]\&#39; }
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenPropsRemoveDelete(tokenId: string, props: string, options?: any): AxiosPromise<object> {
            return localVarFp.tokenPropsRemoveDelete(tokenId, props, options).then((request) => request(axios, basePath));
        },
        /**
         * Use this Endpoint to Facilitate Moving Tokens from one Player to Another
         * @summary Transfer Tokens
         * @param {SDTokenTransferRequest} sDTokenTransferRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenTransferPost(sDTokenTransferRequest: SDTokenTransferRequest, options?: any): AxiosPromise<object> {
            return localVarFp.tokenTransferPost(sDTokenTransferRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Withdraw tokens from a Stardust Wallet
         * @summary Withdraw Token
         * @param {SDTokenWithdrawRequest} sDTokenWithdrawRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenWithdrawPost(sDTokenWithdrawRequest: SDTokenWithdrawRequest, options?: any): AxiosPromise<object> {
            return localVarFp.tokenWithdrawPost(sDTokenWithdrawRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TokenEndpointsApi - object-oriented interface
 * @export
 * @class TokenEndpointsApi
 * @extends {BaseAPI}
 */
export class TokenEndpointsApi extends BaseAPI {
    /**
     * Burns token on-chain. Cannot be reversed.
     * @summary Burn Token
     * @param {SDTokenBurnRequest} sDTokenBurnRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenEndpointsApi
     */
    public tokenBurnPost(sDTokenBurnRequest: SDTokenBurnRequest, options?: AxiosRequestConfig) {
        return TokenEndpointsApiFp(this.configuration).tokenBurnPost(sDTokenBurnRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Some of the details of this token are based upon the Template that it was created from (using token/mint)
     * @summary Get Token
     * @param {string} tokenIds Stringify Array of token ids (ex. \&#39;[3589, 3580]\&#39;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenEndpointsApi
     */
    public tokenGetGet(tokenIds: string, options?: AxiosRequestConfig) {
        return TokenEndpointsApiFp(this.configuration).tokenGetGet(tokenIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mint tokens to a player
     * @summary Mint Tokens
     * @param {SDTokenMintBulkRequest} sDTokenMintBulkRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenEndpointsApi
     */
    public tokenMintBulkPost(sDTokenMintBulkRequest: SDTokenMintBulkRequest, options?: AxiosRequestConfig) {
        return TokenEndpointsApiFp(this.configuration).tokenMintBulkPost(sDTokenMintBulkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mutates a Property of a Token
     * @summary Mutate Token
     * @param {SDTokenMutateRequest} sDTokenMutateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenEndpointsApi
     */
    public tokenMutatePut(sDTokenMutateRequest: SDTokenMutateRequest, options?: AxiosRequestConfig) {
        return TokenEndpointsApiFp(this.configuration).tokenMutatePut(sDTokenMutateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes a Tokens Property from Your Game
     * @summary Remove Token Property
     * @param {string} tokenId Token Id returned from token/create (ex. 5)
     * @param {string} props Stringify Array of token mutable property names ex: \&#39;[\&quot;exp\&quot;, \&quot;health\&quot;]\&#39; }
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenEndpointsApi
     */
    public tokenPropsRemoveDelete(tokenId: string, props: string, options?: AxiosRequestConfig) {
        return TokenEndpointsApiFp(this.configuration).tokenPropsRemoveDelete(tokenId, props, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Use this Endpoint to Facilitate Moving Tokens from one Player to Another
     * @summary Transfer Tokens
     * @param {SDTokenTransferRequest} sDTokenTransferRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenEndpointsApi
     */
    public tokenTransferPost(sDTokenTransferRequest: SDTokenTransferRequest, options?: AxiosRequestConfig) {
        return TokenEndpointsApiFp(this.configuration).tokenTransferPost(sDTokenTransferRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Withdraw tokens from a Stardust Wallet
     * @summary Withdraw Token
     * @param {SDTokenWithdrawRequest} sDTokenWithdrawRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenEndpointsApi
     */
    public tokenWithdrawPost(sDTokenWithdrawRequest: SDTokenWithdrawRequest, options?: AxiosRequestConfig) {
        return TokenEndpointsApiFp(this.configuration).tokenWithdrawPost(sDTokenWithdrawRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


